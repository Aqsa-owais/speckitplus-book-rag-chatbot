---
title: Translating Natural Language to ROS 2 Actions
---

# Translating Natural Language Goals into ROS 2 Actions

## Introduction

The translation layer is the crucial bridge between high-level natural language commands and low-level ROS 2 actions. This component takes the cognitive plans generated by LLMs and converts them into executable ROS 2 messages, services, and actions that can control the robotic system.

## Architecture of the Translation Layer

The translation process involves several stages:

```
Natural Language → LLM Plan → Action Mapping → ROS 2 Messages → Robot Execution
```

## Action Mapping Strategy

### Defining Action Vocabulary

First, we need to define the mapping between high-level actions and ROS 2 interfaces:

```python
class ActionTranslator:
    def __init__(self):
        # Define the mapping between high-level actions and ROS 2 interfaces
        self.action_mapping = {
            # Navigation actions
            'move_to': {
                'type': 'action',
                'interface': 'move_base_msgs/MoveBaseAction',
                'topic': 'move_base',
                'converter': self.convert_navigation_action
            },
            'navigate_to': {
                'type': 'action',
                'interface': 'move_base_msgs/MoveBaseAction',
                'topic': 'move_base',
                'converter': self.convert_navigation_action
            },

            # Manipulation actions
            'pick_up': {
                'type': 'action',
                'interface': 'control_msgs/GripperCommandAction',
                'topic': 'gripper_controller/gripper_action',
                'converter': self.convert_gripper_action
            },
            'grasp': {
                'type': 'action',
                'interface': 'control_msgs/GripperCommandAction',
                'topic': 'gripper_controller/gripper_action',
                'converter': self.convert_gripper_action
            },

            # Communication actions
            'speak': {
                'type': 'publisher',
                'interface': 'std_msgs/String',
                'topic': 'tts_input',
                'converter': self.convert_speak_action
            },

            # Sensing actions
            'look_at': {
                'type': 'service',
                'interface': 'sensor_msgs/SetCameraInfo',
                'service': 'camera/set_parameters',
                'converter': self.convert_look_action
            }
        }

    def convert_navigation_action(self, params):
        """Convert navigation parameters to MoveBaseGoal"""
        from move_base_msgs.msg import MoveBaseGoal
        from geometry_msgs.msg import Pose
        from std_msgs.msg import Header

        goal = MoveBaseGoal()
        goal.target_pose.header = Header()
        goal.target_pose.header.frame_id = "map"
        goal.target_pose.header.stamp = rospy.Time.now()

        # Convert location name to coordinates (would use a map lookup in practice)
        location_coords = self.get_location_coordinates(params.get('location', ''))
        goal.target_pose.pose.position.x = location_coords[0]
        goal.target_pose.pose.position.y = location_coords[1]
        goal.target_pose.pose.orientation.z = location_coords[2]  # yaw
        goal.target_pose.pose.orientation.w = location_coords[3]  # w component

        return goal

    def convert_gripper_action(self, params):
        """Convert gripper parameters to GripperCommand"""
        from control_msgs.msg import GripperCommand
        from control_msgs.msg import GripperCommandActionGoal

        command = GripperCommand()
        command.position = params.get('width', 0.0)  # in meters
        command.max_effort = params.get('effort', 100.0)  # in Newtons

        action_goal = GripperCommandActionGoal()
        action_goal.goal.command = command

        return action_goal

    def convert_speak_action(self, params):
        """Convert speak parameters to String message"""
        from std_msgs.msg import String

        msg = String()
        msg.data = params.get('text', '')
        return msg

    def convert_look_action(self, params):
        """Convert look parameters to camera service request"""
        from sensor_msgs.srv import SetCameraInfo

        # This would be a service request
        req = SetCameraInfo()
        # Set camera parameters based on look target
        return req
```

## ROS 2 Interface Implementation

### Publisher-Based Actions

For simple, one-way commands:

```python
class PublisherActionExecutor:
    def __init__(self):
        # Publishers for different action types
        self.speak_pub = rospy.Publisher('/tts_input', String, queue_size=10)
        self.cmd_vel_pub = rospy.Publisher('/cmd_vel', Twist, queue_size=10)
        self.arm_pub = rospy.Publisher('/arm_controller/command', JointTrajectory, queue_size=10)

    def execute_publisher_action(self, action_type, params):
        """Execute an action via ROS 2 publisher"""
        if action_type == 'speak':
            msg = String()
            msg.data = params.get('text', '')
            self.speak_pub.publish(msg)
            return True
        elif action_type == 'move_base':
            msg = Twist()
            msg.linear.x = params.get('linear_speed', 0.0)
            msg.angular.z = params.get('angular_speed', 0.0)
            self.cmd_vel_pub.publish(msg)
            return True
        else:
            rospy.logwarn(f"Unknown publisher action: {action_type}")
            return False
```

### Service-Based Actions

For synchronous, request-response interactions:

```python
class ServiceActionExecutor:
    def __init__(self):
        # Service clients
        self.get_plan_client = rospy.ServiceProxy('/move_base/make_plan', GetPlan)
        self.transform_client = rospy.ServiceProxy('/tf/transform', LookupTransform)

    def execute_service_action(self, action_type, params):
        """Execute an action via ROS 2 service"""
        try:
            if action_type == 'get_path_plan':
                # Call the path planning service
                start_pose = PoseStamped()
                start_pose.header.frame_id = "map"
                start_pose.pose = params.get('start_pose', Pose())

                goal_pose = PoseStamped()
                goal_pose.header.frame_id = "map"
                goal_pose.pose = params.get('goal_pose', Pose())

                tolerance = params.get('tolerance', 0.5)

                response = self.get_plan_client(start_pose, goal_pose, tolerance)
                return response.plan
            else:
                rospy.logwarn(f"Unknown service action: {action_type}")
                return None
        except rospy.ServiceException as e:
            rospy.logerr(f"Service call failed: {e}")
            return None
```

### Action-Based Actions

For long-running tasks with feedback:

```python
class ActionActionExecutor:
    def __init__(self):
        # Action clients
        self.move_base_client = actionlib.SimpleActionClient('move_base', MoveBaseAction)
        self.gripper_client = actionlib.SimpleActionClient('gripper_action', GripperCommandAction)
        self.arm_client = actionlib.SimpleActionClient('arm_controller/follow_joint_trajectory', FollowJointTrajectoryAction)

        # Wait for servers to be available
        self.move_base_client.wait_for_server()
        self.gripper_client.wait_for_server()
        self.arm_client.wait_for_server()

    def execute_navigation_action(self, goal_pose):
        """Execute navigation action with feedback"""
        goal = MoveBaseGoal()
        goal.target_pose = goal_pose

        # Send goal and wait for result
        self.move_base_client.send_goal(goal)

        # Optionally wait for result or return handle for async processing
        result = self.move_base_client.wait_for_result()
        return self.move_base_client.get_result()

    def execute_manipulation_action(self, gripper_command):
        """Execute gripper manipulation action"""
        goal = GripperCommandGoal()
        goal.command = gripper_command

        self.gripper_client.send_goal(goal)
        result = self.gripper_client.wait_for_result()
        return self.gripper_client.get_result()
```

## Complete Translation System

Here's a complete system that combines all translation approaches:

```python
#!/usr/bin/env python3

import rospy
import actionlib
import json
from std_msgs.msg import String, Bool
from geometry_msgs.msg import Twist, Pose
from move_base_msgs.msg import MoveBaseAction, MoveBaseGoal
from control_msgs.msg import GripperCommandAction, GripperCommandGoal
from trajectory_msgs.msg import JointTrajectory
from control_msgs.msg import FollowJointTrajectoryAction, FollowJointTrajectoryGoal

class CompleteTranslationSystem:
    def __init__(self):
        rospy.init_node('translation_system')

        # Initialize action clients
        self.move_base_client = actionlib.SimpleActionClient('move_base', MoveBaseAction)
        self.gripper_client = actionlib.SimpleActionClient('gripper_action', GripperCommandAction)
        self.arm_client = actionlib.SimpleActionClient('arm_controller/follow_joint_trajectory', FollowJointTrajectoryAction)

        # Publishers for direct commands
        self.speak_pub = rospy.Publisher('/tts_input', String, queue_size=10)
        self.cmd_vel_pub = rospy.Publisher('/cmd_vel', Twist, queue_size=10)

        # Subscribers
        self.plan_sub = rospy.Subscriber('/robot/task_plan', String, self.plan_callback)
        self.status_pub = rospy.Publisher('/robot/execution_status', String, queue_size=10)

        # Wait for action servers
        rospy.loginfo("Waiting for action servers...")
        self.move_base_client.wait_for_server()
        self.gripper_client.wait_for_server()
        self.arm_client.wait_for_server()
        rospy.loginfo("All action servers available")

    def plan_callback(self, msg):
        """Process incoming task plans"""
        try:
            plan_data = json.loads(msg.data)
            rospy.loginfo(f"Received plan: {plan_data['command']}")

            success = self.execute_plan(plan_data)

            # Publish execution status
            status_msg = String()
            status_msg.data = json.dumps({
                'success': success,
                'command': plan_data['command'],
                'timestamp': rospy.Time.now().to_sec()
            })
            self.status_pub.publish(status_msg)

        except json.JSONDecodeError:
            rospy.logerr("Received invalid JSON plan")
        except Exception as e:
            rospy.logerr(f"Error processing plan: {e}")

    def execute_plan(self, plan_data):
        """Execute a complete task plan"""
        plan = plan_data.get('plan', [])

        for i, step in enumerate(plan):
            action = step.get('action')
            params = step.get('parameters', {})

            rospy.loginfo(f"Executing step {i+1}/{len(plan)}: {action} with {params}")

            success = self.execute_single_action(action, params)

            if not success:
                rospy.logerr(f"Action {action} failed")
                return False

            # Small delay between actions to allow for proper execution
            rospy.sleep(0.5)

        rospy.loginfo("Plan completed successfully")
        return True

    def execute_single_action(self, action, params):
        """Execute a single action based on its type"""
        try:
            if action in ['move_to', 'navigate_to', 'go_to']:
                return self.execute_navigation(params)
            elif action in ['pick_up', 'grasp', 'grab']:
                return self.execute_grasp(params)
            elif action in ['speak', 'say', 'talk']:
                return self.execute_speak(params)
            elif action in ['move_arm', 'position_arm']:
                return self.execute_arm_movement(params)
            elif action in ['move_base', 'drive']:
                return self.execute_direct_movement(params)
            else:
                rospy.logwarn(f"Unknown action: {action}")
                return False
        except Exception as e:
            rospy.logerr(f"Error executing action {action}: {e}")
            return False

    def execute_navigation(self, params):
        """Execute navigation action"""
        goal = MoveBaseGoal()
        goal.target_pose.header.frame_id = "map"
        goal.target_pose.header.stamp = rospy.Time.now()

        # Get target coordinates (in a real system, this would look up locations)
        target = self.get_location_coordinates(params.get('location', ''))
        if target is None:
            rospy.logerr(f"Unknown location: {params.get('location')}")
            return False

        goal.target_pose.pose.position.x = target[0]
        goal.target_pose.pose.position.y = target[1]
        goal.target_pose.pose.orientation.z = target[2]  # yaw
        goal.target_pose.pose.orientation.w = target[3]  # w component

        self.move_base_client.send_goal(goal)
        finished_within_time = self.move_base_client.wait_for_result(rospy.Duration(60.0))

        if not finished_within_time:
            rospy.logerr("Navigation action timed out")
            return False

        result = self.move_base_client.get_result()
        return result is not None

    def execute_grasp(self, params):
        """Execute gripper grasp action"""
        goal = GripperCommandGoal()
        goal.command.position = params.get('width', 0.0)  # in meters
        goal.command.max_effort = params.get('effort', 100.0)  # in Newtons

        self.gripper_client.send_goal(goal)
        finished_within_time = self.gripper_client.wait_for_result(rospy.Duration(10.0))

        if not finished_within_time:
            rospy.logerr("Grasp action timed out")
            return False

        result = self.gripper_client.get_result()
        return result is not None

    def execute_speak(self, params):
        """Execute speech action"""
        text = params.get('text', '')
        if not text:
            rospy.logwarn("Empty text for speech action")
            return True  # Considered successful if no text provided

        msg = String()
        msg.data = text
        self.speak_pub.publish(msg)
        rospy.loginfo(f"Speaking: {text}")

        # Wait for TTS to complete (approximate)
        text_length = len(text.split())
        rospy.sleep(text_length * 0.2)  # Rough estimate: 0.2 seconds per word

        return True

    def execute_arm_movement(self, params):
        """Execute arm movement action"""
        # This is a simplified example - real implementation would depend on your arm
        goal = FollowJointTrajectoryGoal()

        # Set joint positions based on parameters
        # In a real system, you'd convert high-level commands to joint trajectories
        goal.trajectory = self.create_joint_trajectory(params)

        self.arm_client.send_goal(goal)
        finished_within_time = self.arm_client.wait_for_result(rospy.Duration(30.0))

        if not finished_within_time:
            rospy.logerr("Arm movement action timed out")
            return False

        result = self.arm_client.get_result()
        return result is not None

    def execute_direct_movement(self, params):
        """Execute direct base movement"""
        msg = Twist()
        msg.linear.x = params.get('linear_speed', 0.0)
        msg.angular.z = params.get('angular_speed', 0.0)

        # Publish movement command for specified duration
        duration = params.get('duration', 1.0)

        rate = rospy.Rate(10)  # 10 Hz
        start_time = rospy.Time.now()

        while (rospy.Time.now() - start_time).to_sec() < duration:
            self.cmd_vel_pub.publish(msg)
            rate.sleep()

        # Stop the robot
        stop_msg = Twist()
        self.cmd_vel_pub.publish(stop_msg)

        return True

    def get_location_coordinates(self, location_name):
        """Get coordinates for a named location (simplified lookup)"""
        # In a real system, this would query a map or database
        locations = {
            'kitchen': [2.0, 1.0, 0.0, 1.0],  # [x, y, z, w]
            'living_room': [0.0, 0.0, 0.0, 1.0],
            'bedroom': [-2.0, 1.0, 0.0, 1.0],
            'office': [1.0, -2.0, 0.0, 1.0]
        }

        return locations.get(location_name.lower().replace(' ', '_'))

    def create_joint_trajectory(self, params):
        """Create a joint trajectory for arm movement"""
        # Simplified implementation
        from trajectory_msgs.msg import JointTrajectory, JointTrajectoryPoint

        trajectory = JointTrajectory()
        trajectory.joint_names = ['joint1', 'joint2', 'joint3']  # Example joint names

        point = JointTrajectoryPoint()
        point.positions = params.get('joint_positions', [0.0, 0.0, 0.0])
        point.velocities = [0.0, 0.0, 0.0]
        point.time_from_start = rospy.Duration(5.0)  # 5 seconds to reach position

        trajectory.points.append(point)
        return trajectory

if __name__ == '__main__':
    try:
        translator = CompleteTranslationSystem()
        rospy.spin()
    except rospy.ROSInterruptException:
        pass
```

## Error Handling and Recovery

### Graceful Degradation

Implement fallback strategies when translation fails:

```python
class RobustTranslationSystem(CompleteTranslationSystem):
    def __init__(self):
        super().__init__()
        self.fallback_strategies = {
            'navigation_failure': self.fallback_navigation,
            'grasp_failure': self.fallback_grasp,
            'communication_failure': self.fallback_communication
        }

    def execute_single_action(self, action, params):
        """Execute action with error handling and fallbacks"""
        try:
            result = super().execute_single_action(action, params)
            if not result:
                # Try fallback strategy
                fallback_result = self.execute_fallback(action, params)
                return fallback_result
            return result
        except Exception as e:
            rospy.logerr(f"Action execution failed: {e}")
            # Attempt fallback
            return self.execute_fallback(action, params)

    def execute_fallback(self, action, params):
        """Execute fallback strategy for failed actions"""
        fallback_method = self.fallback_strategies.get(f"{action}_failure")
        if fallback_method:
            rospy.loginfo(f"Attempting fallback for {action}")
            return fallback_method(params)
        else:
            rospy.logerr(f"No fallback available for {action}")
            return False

    def fallback_navigation(self, params):
        """Fallback navigation strategy"""
        # Try alternative path planning or ask for human assistance
        rospy.loginfo("Using alternative navigation approach")
        # Implementation would depend on specific fallback strategy
        return True  # Simplified
```

## Integration with Capstone Project

The translation system is a key component of the end-to-end autonomous humanoid system, connecting the high-level cognitive planning with the low-level robot control. It ensures that natural language commands can be executed reliably by the robotic platform.

## Best Practices

1. **Validation**: Always validate action parameters before execution
2. **Timeouts**: Implement appropriate timeouts for all actions
3. **Feedback**: Provide feedback on action execution status
4. **Safety**: Include safety checks before executing actions
5. **Logging**: Log all translation and execution events for debugging
6. **Modularity**: Keep translation logic modular for easy extension

This translation layer completes the VLA system by converting abstract language commands into concrete robot actions, enabling the autonomous humanoid robot to respond to natural language instructions.